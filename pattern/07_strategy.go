package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern

Паттерн Стратегия представляет шаблон проектирования, который определяет набор алгоритмов, инкапсулируеткаждый из них и
обеспечивает их взаимозаменяемость. В зависимости от ситуации мы можем легко заменить один используемый алгоритм другим.
При этом замена алгоритма происходит независимо от объекта, который использует данный алгоритм.

Когда применять?
	- Когда есть несколько родственных классов, которые отличаются поведением. Можно задать один основной класс, а разные
	варианты поведения вынести в отдельные классы и при необходимости их применять.
	- Когда необходимо обеспечить выбор из нескольких вариантов алгоритмов, которые можно легко менять в зависимости от условий.
	- Когда необходимо менять поведение объектов на стадии выполнения программы.
	- Когда класс, применяющий определенную функциональность, ничего не должен знать о ее реализации.

Плюсы:
	- горячая замена алгоритмов на лету;
	- изолирует код и данные алгоритмов от остальных классов;
	- уход от наследования к делегированию;
	- реализует принцип открытости/закрытости.
Минусы:
	- усложняет программу за счёт дополнительных классов;
	- клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

Ниже приведена реализация паттерна "Стратегия" на примере создания гибридного автомобиля. Интерфейс Movable описывает метод
движения автомобиля. Структура PetrolMove реализует этот метод позволяя автомобилю использующему его двигаться на бензине.
Структура ElectricMove реализует движение на электричестве. Гибридный автомобиль может переключаться между видом энергии и
двигаться на бензине или электричестве.
*/

// Интерфейс Движимый
type Movable interface {
	Move() // Двигаться
}

// Бензин
type PetrolMove struct{}

// Создать энергию
func NewPetrolMove() *PetrolMove {
	return &PetrolMove{}
}

// Использовать бензин
func (petrol *PetrolMove) Move() {
	fmt.Println("Движение на бензине")
}

// Электричество
type ElectricMove struct{}

// Создать энергию
func NewElectricMove() *ElectricMove {
	return &ElectricMove{}
}

// Использовать электричество
func (petrol *ElectricMove) Move() {
	fmt.Println("Движение на электричестве")
}

// Структура Автомобиль
type Car struct {
	Model       string  // Модель автомобиля
	Passengers  int     // Количество пассажиров
	MovableType Movable // Тип энергии
}

// Создать автомобиль
func NewCar(model string, passengers int, movableType Movable) *Car {
	return &Car{model, passengers, movableType}
}

// Изменить тип энергии
func (car *Car) SetMovable(movable Movable) {
	car.MovableType = movable
}

// Двигаться
func (car *Car) Move() {
	car.MovableType.Move()
}

// Использование автомобиля клиентом
// func main() {
// 	car := NewCar("Volvo", 4, NewPetrolMove())
// 	car.Move()
// 	car.SetMovable(NewElectricMove())
// 	car.Move()
// }

// Результат работы программы
/*
Движение на бензине
Движение на электричестве
*/
